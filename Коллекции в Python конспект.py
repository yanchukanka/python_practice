#                       Конспект статьи на Хабре Python: коллекции
# часть 1/4: классификация, общие подходы и методы, конвертация

# Последовательности бывают изменяемые и неизменяемые
#                             list       string, tuple

# множества могут быть изменяемые(set) и неизменяемые(frozenset)

# и маппинги (dict)


# Операции с коллекциями:
# 1.Печать элементов коллекции с помощью функции print()
# 2. Подсчёт количества членов коллекции с помощью функции len()
# 3. Проверка принадлежности (in)
# 4. Обход всех элементов коллекции в цикле for in

for elm in my_list:
    print(elm)

# У прохода в цикле по словарю есть свои особенности:

 for elm in my_dict: # При таком обходе словаря, перебираются только ключи, равносильно for elm in my_dict.keys()

# 5. Функции min(), max(), sum()


# МЕТОДЫ:
# .count() — метод подсчета определенных элементов для неуникальных коллекций (строка, список, кортеж), возвращает сколько раз элемент встречается в коллекции
# .index() — возвращает минимальный индекс переданного элемента для индексированных коллекций (строка, список, кортеж)
# .copy() — метод возвращает неглубокую (не рекурсивную) копию коллекции (список, словарь, оба типа множества).
#.clear() — метод изменяемых коллекций (список, словарь, множество), удаляющий из коллекции все элементы и превращающий её в пустую коллекцию.

#    !!! при преобразовании одной коллекции в другую возможна потеря данных !!!

# создаем строку из list:
my_tuple = ('a', 'b', 'c')
my_str = ''.join(my_tuple)
print(my_str)  # abc




# часть 2/4: индексирование, срезы, сортировка

# 1. Индексирование (список (list), кортеж (tuple), строку (string))
# ! Поскольку кортежи и строки у нас неизменяемые коллекции, то по индексу мы можем только брать элементы, но не менять их
#
# ! списки меняем легко:
my_list = [1, 2, 3, [4, 5]]
my_list[0] = 10
my_list[-1][0] = 40
print(my_list)  # [10, 2, 3, [40, 5]]


# 2. Срезы

my_collection[start:stop:step]

#  ! Следует помнить, что взяв элемент по индексу или срезом (slice) мы никак не меняем исходную коллекцию, мы просто скопировали ее часть для дальнейшего использования
# ! При срезе, первый индекс входит в выборку, а второй нет!
#
# Полезная штука именованные срезы! => ФУНКЦИЯ slice()
person = ('Alex', 'Smith', "May", 10, 1980)
NAME, BIRTHDAY = slice(None, 2), slice(2, None)
print(person[NAME])      # ('Alex', 'Smith')
print(person[BIRTHDAY])  # ('May', 10, 1980)

# Для вставки одиночных элементов в list: .append() и .insert():

# Меняем части списка с помощью срезов
my_list = [1, 2, 3, 4, 5]
my_list[1:3] = [20, 30]
print(my_list)          # [1, 20, 30, 4, 5]
my_list[1:3] = [0]      # нет проблем заменить два элемента на один
print(my_list)          # [1, 0, 4, 5]
my_list[2:] = [40, 50, 60]   # или два элемента на три
print(my_list)               # [1, 0, 40, 50, 60]


# 3. Сортировка элементов коллекции
#    3.1 Функция sorted()
#        * функция не меняет исходную коллекцию, а возвращает новый список из ее элементов;
#        * не зависимо от типа исходной коллекции, вернётся список (list) ее элементов;
#        * поскольку она не меняет исходную коллекцию, ее можно применять к неизменяемым коллекциям;
#        * Поскольку при сортировке возвращаемых элементов нам не важно, был ли у элемента некий индекс в исходной
#        коллекции, можно применять к неиндексированным коллекциям;
#        * Имеет дополнительные не обязательные аргументы:
#             reverse=True — сортировка в обратном порядке
#             key=funcname (начиная с Python 2.4) — сортировка с помощью специальной функции funcname, она может быть как стандартной функцией Python, так и специально написанной вами для данной задачи функцией и лямбдой.

#    3.2 Функция reversed()
#        * возвращает генератор списка, а не сам список;
#        * если нужно получить не генератор, а готовый список, результат можно обернуть в list() или же вместо
#        reversed() воспользоваться срезом [: :-1];
#        * она не сортирует элементы, а возвращает их в обратном порядке, то есть читает с конца списка;
#        * из предыдущего пункта понятно, что если у нас коллекция неиндексированная — мы не можем вывести её
#        элементы в обратном порядке и эта функция к таким коллекциям не применима — получим
#        «TypeError: argument to reversed() must be a sequence»;
#        * не позволяет использовать дополнительные аргументы — будет ошибка «TypeError: reversed() does not take
#        keyword arguments».


#    3.3 Методы списка .sort() и .reverse()
#        * Меняют сам исходный список, а не генерируют новый;
#        * Возвращают None, а не новый список;
#        * поддерживают те же дополнительные аргументы;
#        * в них не надо передавать сам список первым параметром, более того, если это сделать —
#        будет ошибка — не верное количество аргументов.
#
#
#    3.4 Cортировка словаря
#        * sorted(my_dict) — когда мы передаем в функцию сортировки словарь без вызова его дополнительных методов — идёт перебор только ключей, сортированный список ключей нам и возвращается;
#        * sorted(my_dict.keys()) — тот же результат, что в предыдущем примере, но прописанный более явно;
#        * sorted(my_dict.items()) — возвращается сортированный список кортежей (ключ, значение), сортированных по ключу;
#        * sorted(my_dict.values()) — возвращается сортированный список значений

my_dict = {'a': 1, 'c': 3, 'e': 5, 'f': 6, 'b': 2, 'd': 4}
mysorted = sorted(my_dict)
print(mysorted)  # ['a', 'b', 'c', 'd', 'e', 'f']
mysorted = sorted(my_dict.items())
print(mysorted)  # [('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e', 5), ('f', 6)]
mysorted = sorted(my_dict.values())
print(mysorted)  # [1, 2, 3, 4, 5, 6]

# !!!! Сортировка словаря по значениям, если нам надо выводить пары в порядке сортировки по значению.
population = {"Shanghai": 24256800, "Karachi": 23500000, "Beijing": 21516000, "Delhi": 16787941}
population_sorted = sorted(population.
                           (), key=lambda x: x[1])  # отсортируем по возрастанию населения:
print(population_sorted)





#  часть 3/4: объединение коллекций, добавление и удаление элементов

#    1. Объединение
#     * через конкатенацию
tuple1 = (1, 2, 3)
tuple2 = (4, 5)
tuple3 = tuple1 + tuple2
print(tuple3)       # (1, 2, 3, 4, 5)

#     * объединить словари можно так:
dict1 = {'a': 1, 'b': 2}
dict2 = {'c': 3, 'd': 4}
dict3 = dict1.copy()
dict3.update(dict2)
print(dict3)        	# {'a': 1, 'c': 3, 'b': 2, 'd': 4}
#  или так:
dict1 = {'a': 1, 'b': 2}
dict2 = {'c': 3, 'd': 4}
dict3 = {**dict1, **dict2}
print(dict3)        	# {'a': 1, 'c': 3, 'b': 2, 'd': 4}


#     * объединение и пересечение множеств доступны в инфографике***






# часть 4/4: Все о выражениях-генераторах, генераторах списков, множеств и словарей

#     какие есть виды:
#       * выражение-генератор (generator expression) — ЭТО выражение в круглых скобках которое выдает создает на каждой итерации новый элемент по правилам.
list_a = [-2, -1, 0, 1, 2, 3, 4, 5]
my_gen = (i for i in list_a)
print(sum(my_gen))  # 12

#       * list comprehension
#       * set comprehension
#       * dictionary comprehension

# вариант ветвления if-else в генераторе словарей
list_a = [-2, -1, 0, 1, 2, 3, 4, 5]
list_b = [x if x < 0 else x**2 for x in list_a]
# Если x-отрицательное - берем x, в остальных случаях - берем квадрат x
print(list_b)   # [-2, -1, 0, 1, 4, 9, 16, 25]

#  еще вариант с ветвлением
list_a = [-2, -1, 0, 1, 2, 3, 4, 5]
list_b = [x**3 if x < 0 else x**2 for x in list_a if x % 2 == 0]
# вначале фильтр пропускает в выражение только четные значения
# после этого ветвление в выражении для отрицательных возводит в куб, а для остальных в квадрат
print(list_b)   # [-8, 0, 4, 16]


#  генераторы можно писать на разных строках:
numbers = range(10)
squared_evens = [
    n ** 2
    for n in numbers
    if n % 2 == 0
]  # тут генератор заканчивается


#  генератор выражений для списка(то же самое можно для множеств и кортежа)
list_a = [-2, -1, 0, 1, 2, 3, 4, 5]
my_list = list(i for i in list_a)
print(my_list)          # [-2, -1, 0, 1, 2, 3, 4, 5]


# можно сгенерировать строку из списка с помощью join
list_a = [-2, -1, 0, 1, 2, 3, 4, 5]
my_str = ''.join(str(x) for x in list_a)
print(my_str)  #  получится строка '-2-1012345'




# enumerate() + ГЕНЕРАТОРЫ

for i, x in enumerate(iterable)  # здесь x — текущий элемент i — его порядковый номер, начиная с нуля

# а теперь выведем индекс и соответствующий ему элемент списка в кортежах
list_a = [-2, -1, 0, 1, 2, 3, 4, 5]
list_d = [(i, x) for i, x in enumerate(list_a)]
print(list_d)  # [(0, -2), (1, -1), (2, 0), (3, 1), (4, 2), (5, 3), (6, 4), (7, 5)]


#Теперь попробуем решить реальную задачу — выберем в генераторе списка каждый третий элемент из исходного списка:
list_a = [-2, -1, 0, 1, 2, 3, 4, 5]
list_e = [x for i, x in enumerate(list_a, 1) if i % 3 == 0]
print(list_e)   # [0, 3]



# вложенные циклы и ГЕНЕРАТОРЫ

# Допустим у нас есть матрица. И мы желаем преобразовать ее в [0, 1, 2, 3, 10, 11, 12, 13, 20, 21, 22, 23].
matrix = [[0, 1, 2, 3],
          [10, 11, 12, 13],
          [20, 21, 22, 23]]
flattened = [n for row in matrix for n in row]
print(flattened)